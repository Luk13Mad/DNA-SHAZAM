import numpy as np
import pandas as pd
import argparse
import os
import sys
import itertools as itt


parser = argparse.ArgumentParser(description='feature extraction')
parser.add_argument('-in',"--input", type=str,help='input file, full path',required=True)
parser.add_argument('-db',"--database", type=str,help='generate fingerprint for database? Y/N',required=True)
parser.add_argument('-out',"--output", type=str,help='output directory',default=os.getcwd())
parser.add_argument('-off',"--offset", type=int,help='offset between anchor and target zone',default=3)


args = vars(parser.parse_args())


'''
script generates adresses for each point. input is file with feature vectors.
output can be for database or query
'''

def read_input_to_df(file):
    '''
    reads .csv file with feature vectors
    .csv-file generated by feature_extraction.py
    labels columns 
    Parameters
    ----------
    file: input file with data
    Returns
    -------
    dataframe
    '''
    try:
        df=pd.read_csv(file, sep ="\t", header = None, compression='gzip')
    except FileNotFoundError:
        sys.exit("input file not found")
        
    df.columns=["cnt","feature","length"]
    return df
    

def order(df):
    '''
    takes df with feature vectors
    assigns order to points
    Parameters
    ----------
    df: input file with data
    Returns
    -------
    df
    '''
    df_sorted=df.sort_values(by=['cnt','length'],ascending=[True,True])
    df_sorted=df_sorted.reset_index(drop=True)
    return df_sorted
    
def make_zones_anchors(df,offset):
    '''
    takes df with feature vectors and offset value
    returns pairs of anchors:targetzones
    
    Parameters
    ----------
    df: input df
    offset: offset value
    
    Returns
    -------
    generator
    '''
    idx=list(df.index)
    anchors=idx[0:(len(idx)-offset-5+1)]
    for i,j in zip(idx[offset:],anchors):
        zone=df.iloc[i:i+5]
        if len(zone)==5:
            yield (df.iloc[j],zone)
        else:
            continue
    
def adresses_from_generator(anchor,zone):
    for idx,line in zone.iterrows():
        delta=abs(anchor["cnt"]-line["cnt"])
        tmp=[(int(anchor["feature"]),int(line["feature"]),delta),(anchor["cnt"],id)]
        tmp_adresses.append(tmp)

def print_adress_to_file(adresses,db):
    '''
    write adresses to file
    Parameters
    ----------
    adresses: list with adresses from make_adress
    '''
    if (str(db)!="Y") & (str(db)!="N"):
        sys.exit("argument for -db must be \"Y\" or \"N\" ")
    
    if str(db)=="Y":
        line1=[]
        line2=[]
        for l in adresses:
            line1.append(l[0])
            line2.append(l[1])
        d={"points":line1,"couple":line2}
        tmp=pd.DataFrame.from_dict(d)
        tmp.to_csv("{1}/adress_list_db{0}.csv.gz".format(id,args["output"]),sep="\t",header=False,index=False, compression='gzip')
    else:
        line1=[]
        line2=[]
        for l in adresses:
            line1.append(l[0])
            line2.append(l[1][0])
        d={"points":line1,"couple":line2}
        tmp=pd.DataFrame.from_dict(d)
        tmp.to_csv("{1}/adress_list_query{0}.csv.gz".format(id,args["output"]),sep="\t",header=False,index=False, compression='gzip')
 
id=args["input"].split("/")[-1].split(".")[0]
df=read_input_to_df(args["input"])
ordered_points=order(df)
tmp_adresses=[]
for anchor,zone in make_zones_anchors(ordered_points,args["offset"]):
    adresses_from_generator(anchor,zone)
print("{0} adresses made , {1} target zones made, {3} different kmer sizes used, {4} diagonal length possible, for read: {2}".format(len(tmp_adresses),(len(tmp_adresses)/5),id,len(set(df["length"])),tmp_adresses[-1][-1][0]),file=sys.stderr)
print_adress_to_file(tmp_adresses,args["database"])

print("Done")
